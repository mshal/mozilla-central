#! /usr/bin/env python
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this file,
# You can obtain one at http://mozilla.org/MPL/2.0/.

import os

def generate_rules(sandbox):
    from tup import makefile_parser

    # We need the configure processed Makefile, since that has the real
    # definition of SOURCES for our platform.
    real_makefile_path = os.path.join(sandbox.outputdir, 'Makefile')
    makefile_parser.parse(sandbox, real_makefile_path)

    # This srcdir goes through js/src/ctypes/libffi, and we use it so we can grep
    # out full paths which mess with tup's dependency detection.
    srcdir = sandbox.get_string('abs_top_srcdir')

    all_flags = []
    for flag in sandbox['COMPILE']:
        # Trim down full paths so that they are local to libffi
        if flag.startswith('-I' + srcdir):
            all_flags.append('-I' + flag[len('-I') + len(srcdir) + 1:])
        else:
            all_flags.append(flag)

    # Some headers are generated by libffi's configure and go into the objdir
    all_flags.append('-I' + sandbox.outputdir)

    # OS-specific? This seems to magically appear from libtool
    all_flags.append('-fPIC')
    all_flags.append('-DPIC')

    all_flags_string = ' '.join(all_flags)
    srcs = sandbox['SOURCES']

    # Compile each file. There are duplicates, so remove them by using set()
    for src in set(srcs):
        dirname = os.path.dirname(src)
        print ": %s |> ^ CC %%f^ %s -c %%f -o %%o |> %s/%s/%%B.o {objs}" % (src, all_flags_string, sandbox.outputdir, dirname)
    # Link them into libffi.a
    print ": {objs} |> ^ AR %%o^ ar crs %%o %%f |> %s/libffi.a | $(MOZ_ROOT)/<-lffi>" % (sandbox.outputdir)
