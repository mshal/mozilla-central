#! /usr/bin/python -B

import sys
import re
import tup_client

'''Creates the given config header. A config header is generated by
taking the corresponding source file and replacing some #define/#undef
occurences:
    "#undef NAME" is turned into "#define NAME VALUE"
    "#define NAME" is unchanged
    "#define NAME ORIGINAL_VALUE" is turned into "#define NAME VALUE"
    "#undef UNKNOWN_NAME" is turned into "/* #undef UNKNOWN_NAME */"
    Whitespaces are preserved.

This is essentially duplicated from ConfigStatus:create_config_header(), but is
modified to support tup. The existing ConfigStatus.py could also be modified to
support tup, but that is not trivial since the tup_client doesn't expose an
array of all configuration variables. Instead, configuration variables are
requested on demand, so that tup can accurately track dependences on them.
'''
if len(sys.argv) < 2:
    sys.exit('usage: %s input-file output-file' % sys.argv[0])
input_file = sys.argv[1]
output_file = sys.argv[2]

with open(input_file, 'rU') as input:
    output = open(output_file, "w")
    r = re.compile('^\s*#\s*(?P<cmd>[a-z]+)(?:\s+(?P<name>\S+)(?:\s+(?P<value>\S+))?)?', re.U)
    for l in input:
        m = r.match(l)
        if m:
            cmd = m.group('cmd')
            name = m.group('name')
            value = m.group('value')
            if name:
                tup_value = tup_client.config_var(name)
                if tup_value:
                    if cmd == 'define' and value:
                        l = l[:m.start('value')] + str(tup_value) + l[m.end('value'):]
                    elif cmd == 'undef':
                        l = l[:m.start('cmd')] + 'define' + l[m.end('cmd'):m.end('name')] + ' ' + str(tup_value) + l[m.end('name'):]
                elif cmd == 'undef':
                    l = '/* ' + l[:m.end('name')] + ' */' + l[m.end('name'):]

        output.write(l)
    output.close()
